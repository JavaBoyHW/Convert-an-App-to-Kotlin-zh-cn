1
00:00:00,000 --> 00:00:02,280
现在我们升级查询文件，

2
00:00:02,280 --> 00:00:05,630
让我们处理一些简单的转化来放松一下。

3
00:00:05,630 --> 00:00:08,025
首先，我们处理Notes Data Helper

4
00:00:08,025 --> 00:00:10,170
那个成功转化且没有问题的。

5
00:00:10,170 --> 00:00:12,945
接下来，我们将关注Data Store,

6
00:00:12,945 --> 00:00:16,970
那个我们可以实际上添加一些有趣的优化。

7
00:00:16,970 --> 00:00:21,165
首先，我们把Notes Database添加lateinit修饰，

8
00:00:21,165 --> 00:00:26,395
这些基本释义，我保证这将被初始化在我要使用它时。

9
00:00:26,395 --> 00:00:29,055
这允许我们将变量呈现为非空,

10
00:00:29,055 --> 00:00:31,665
使得我们的代码既干净又安全.

11
00:00:31,665 --> 00:00:34,110
不幸的是，它有些像我们的

12
00:00:34,110 --> 00:00:38,315
Java代码不能那么开心的转化成我们的Data Store.

13
00:00:38,315 --> 00:00:43,860
这是因为KOTLIN编译器将尽可能避免静态变量.

14
00:00:43,860 --> 00:00:48,145
相反，它更喜欢将它们嵌套在实例或伴生对象之下.

15
00:00:48,145 --> 00:00:54,615
在这种情况下，我们就要将它强转为java友好的JVM静态注释.

16
00:00:54,615 --> 00:00:57,225
这是一个Kotlin编译器的强烈提示，

17
00:00:57,225 --> 00:01:01,350
确切地告诉您如何在JVM级别上表示代码.

18
00:01:01,350 --> 00:01:02,670
现在，如你所见，

19
00:01:02,670 --> 00:01:06,280
在我们工作的基础上，创建Activity是更开心.

20
00:01:06,280 --> 00:01:08,340
这些事情最终将由Data Store去做，

21
00:01:08,340 --> 00:01:11,185
将简化我们的执行方法。

22
00:01:11,185 --> 00:01:13,970
这地方实际上是Anko发挥了作用.

23
00:01:13,970 --> 00:01:17,460
Anko实际上提供了一个同步方法

24
00:01:17,460 --> 00:01:21,795
它基本上为你处理了所有的线程池和执行逻辑,

25
00:01:21,795 --> 00:01:25,540
制造了一个极好的AsyncTask替代品。

26
00:01:25,540 --> 00:01:30,720
我们还将修改这个方法的签名，使用Lambda表达式替代一个Runnable

27
00:01:30,720 --> 00:01:34,000
一个可以做更多事的Kotlin的方式.
