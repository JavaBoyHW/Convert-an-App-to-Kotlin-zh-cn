1
00:00:00,000 --> 00:00:02,385
尽可能的帮助你,

2
00:00:02,385 --> 00:00:05,295
Kotlin编译器实际上已经将你的"getall"

3
00:00:05,295 --> 00:00:09,270
方法修改成一个"all."的变量.

4
00:00:09,270 --> 00:00:11,040
现在，一切都好了，

5
00:00:11,040 --> 00:00:15,180
但是你也许注意到这些文件中唯一得到这种处理的方法，

6
00:00:15,180 --> 00:00:19,515
导致了一个不一致和令人困惑的类接口.


7
00:00:19,515 --> 00:00:24,240
由于这个原因，我们也许应该跳进去把它变回一个函数.

8
00:00:24,240 --> 00:00:28,110
下一步，在"loadAllByIDs"方法里，

9
00:00:28,110 --> 00:00:29,430
你应该注意到我们使用了

10
00:00:29,430 --> 00:00:34,635
一个非常复杂的字符构造对象去构造我们的查询参数.

11
00:00:34,635 --> 00:00:39,330
这是Kotlin函数语言扩展的完美候选者.

12
00:00:39,330 --> 00:00:43,632
我们将替换双重"？"和参数构造,

13
00:00:43,632 --> 00:00:46,760
使用数行简单的Kotlin.

14
00:00:46,760 --> 00:00:52,800
我们也选择使用String templates去替代+.

15
00:00:52,800 --> 00:00:56,525
接下里，这是Kotlin可以做的很酷的事之一，

16
00:00:56,525 --> 00:00:59,560
我们实际上将摆脱掉"cursor.close"

17
00:00:59,560 --> 00:01:03,230
而使用"use"方法替换.

18
00:01:03,230 --> 00:01:06,440
这是一个基于lambda的函数，

19
00:01:06,440 --> 00:01:09,970
它简化了可关闭资源的使用，并有助于防止内存泄漏.

20
00:01:09,970 --> 00:01:15,540
我么将lambda值，转化到一个简单的方法引用.

21
00:01:15,540 --> 00:01:17,825
现在，在insert()方法里面，

22
00:01:17,825 --> 00:01:20,175
我们可以做出类似的优化.

23
00:01:20,175 --> 00:01:25,160
感谢onco可以利用transaction()方法

24
00:01:25,160 --> 00:01:30,695
那个使用了单一lambda并将所有的数据库逻辑事务包裹其中.

25
00:01:30,695 --> 00:01:37,355
它自动为你处理try catch，所以我们的代码最终看上去更漂亮.

26
00:01:37,355 --> 00:01:39,740
接下来会对这个文件做一个大改变，

27
00:01:39,740 --> 00:01:43,520
去使用apply()方法，这是一个巧妙的技巧

28
00:01:43,520 --> 00:01:48,575
在lambda表达式里实际上改变这个参数值.

29
00:01:48,575 --> 00:01:52,745
这个指示器引用实际上是不同的.

30
00:01:52,745 --> 00:01:57,395
这是一个非常地有用的技巧在编写变量初始化时，

31
00:01:57,395 --> 00:02:00,485
你可以看到它的应用在note类上.

32
00:02:00,485 --> 00:02:04,430
我们也应用它到去替代"fromnote"方法中的content值.
