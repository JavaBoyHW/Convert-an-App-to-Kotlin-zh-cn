1
00:00:00,000 --> 00:00:03,180
现在我们开始了解recycler相关逻辑,

2
00:00:03,180 --> 00:00:07,965
让我们浏览一下Java样板文件代码中可读性最差的一面,

3
00:00:07,965 --> 00:00:10,190
他们是数据库逻辑。

4
00:00:10,190 --> 00:00:14,685
我们从给数据类进行一个大升级开始吧，

5
00:00:14,685 --> 00:00:19,555
我们将移走查询字符并且换乘一些新方法。

6
00:00:19,555 --> 00:00:22,500
有些讽刺的是

7
00:00:22,500 --> 00:00:26,055
Java只有尽可能复杂它才能写出好的date类。

8
00:00:26,055 --> 00:00:27,705
对一些简单的事情来说，

9
00:00:27,705 --> 00:00:32,715
它实际上需要写令人震惊的很多代码去表达他们。

10
00:00:32,715 --> 00:00:34,830
现在，我们可以去移除setters和getters

11
00:00:34,830 --> 00:00:37,890
当我们第一次转化到Kotlin，

12
00:00:37,890 --> 00:00:40,890
但是我们仍然没有一个很好的说法来描述

13
00:00:40,890 --> 00:00:44,475
一据个有效的数类的一些细节，例如简单的复制,

14
00:00:44,475 --> 00:00:47,170
判等，和映射.

15
00:00:47,170 --> 00:00:51,550
Now, we can fix all that with just a couple of lines of code.
现在，我们可以用几行代码修复他们.

16
00:00:51,550 --> 00:00:54,435
请允许我介绍"Data Class".

17
00:00:54,435 --> 00:00:57,690
数据类是一个特别的结构

18
00:00:57,690 --> 00:01:01,140
告诉Kotlin编译器去注意如下事情，像一致性，

19
00:01:01,140 --> 00:01:04,350
散列，和复制之类.

20
00:01:04,350 --> 00:01:06,480
编译器将从类构造函数中获取所有变量

21
00:01:06,480 --> 00:01:11,405
并使用他们生成类标识.

22
00:01:11,405 --> 00:01:14,593
现在根据经验你知道复制构造函数，

23
00:01:14,593 --> 00:01:18,210
感谢神奇的Kotlin实参特性声明。

24
00:01:18,210 --> 00:01:21,000
这意味着如果你想去

25
00:01:21,000 --> 00:01:24,340
创造一个副本但可能带一些小改动，

26
00:01:24,340 --> 00:01:26,760
只需要一行。
